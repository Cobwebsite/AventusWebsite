<h1>UI - Shortcut</h1>
<p>The <span class="cn">ShortcutManager</span> class provides a global keyboard shortcut management system.
It allows developers to register and handle keyboard combinations (shortcuts) with customizable behavior such as:</p>

<ul>
    <li>Replacing temporary shortcuts,</li>
    <li>Automatically preventing default browser actions,</li>
    <li>Handling async callbacks,</li>
    <li>And restoring previous shortcut states when temporary ones are removed.</li>
</ul>

<h2>Overview</h2>
<p>Keyboard shortcuts are essential for improving productivity and providing advanced user interactions in web applications.</p>
<p>This utility lets you easily bind custom key combinations (like <span class="cn">Ctrl+S</span> or <span class="cn">Alt+Enter</span>) to specific actions while handling complex states such as modifier keys and overlapping combinations.</p>

<h2>Example</h2>
<av-code language="ts">
    <pre>
        // Register a simple shortcut: Ctrl+S
        ShortcutManager.subscribe([SpecialTouch.Control, "s"], () => console.log("saving"));
        // Register a temporary shortcut that replaces the existing Ctrl+S
        const overriding = () => {
            console.log("Temporary override for Ctrl+S");
        }
        ShortcutManager.subscribe([SpecialTouch.Control, "s"], overriding, { replaceTemp: true });
        // Later, remove the temporary shortcut and restore the previous one
        ShortcutManager.unsubscribe([SpecialTouch.Control, "s"], overriding);
    </pre>
</av-code>

<h2>Internal Behavior</h2>
<p>The combination order doesn't matter. <span class="cn">Ctrl+S</span>, <span class="cn">S+Ctrl</span>, or <span class="cn">s+Control</span> are treated identically.</p>

<p>Certain browser shortcuts (like <span class="cn">Ctrl+P</span> or <span class="cn">Ctrl+S</span>) are automatically prevented to avoid conflicts. This can be useful in single-page applications (SPAs) to prevent the browser from executing system actions like Print, Open File, or Save Page. You can customize this behavior with :</p>

<av-code language="ts">
    <pre>
        ShortcutManager.setAutoPrevents([[SpecialTouch.Control, "s"], [SpecialTouch.Control, "p"]]);
    </pre>
</av-code>

<h2>Conditional Shortcuts</h2>
<p>In some cases, you may want a shortcut to be conditionally active. For example, only when a certain modal is open, a form is focused, or the user is in edit mode.</p>
<p>The <span class="cn">ShortcutManager</span> makes this easy: You can return <span class="cn">false</span> from a shortcut callback to indicate that <span class="cn">no action</span> was performed, and that the shortcut should be considered "ignored" in this context.</p>

<av-code language="ts">
    <pre>
let isModalOpen = false;
&nbsp;
ShortcutManager.subscribe(
  [SpecialTouch.Control, "Enter"],
  () => {
    \if (!isModalOpen) {
      // Do nothing â€” signal that shortcut did not apply
      return false;
    }
&nbsp;
    console.log("Submitting modal form...");
    submitModalForm();
  }
);
    </pre>
</av-code>

<h2>Temporary Shortcut Replacement</h2>
<p>The <span class="cn">replaceTemp</span> option lets you temporarily override a shortcut without losing the original.</p>

<av-code language="ts">
    <pre>
const saveShortcut = () => console.log("Save file");
const tempSave = () => console.log("Temporary override");
&nbsp;
// Register base shortcut
ShortcutManager.subscribe([SpecialTouch.Control, "s"], saveShortcut);
&nbsp;
// Temporarily replace
ShortcutManager.subscribe(
  [SpecialTouch.Control, "s"],
  tempSave,
  { replaceTemp: true }
);
&nbsp;
// Later restore
ShortcutManager.unsubscribe([SpecialTouch.Control, "s"], tempSave);
// The original saveShortcut is automatically restored
    </pre>
</av-code>